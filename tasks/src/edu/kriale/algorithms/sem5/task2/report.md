Отчет по лабораторной работе №2
======================================
ИССЛЕДОВАНИЕ И ОЦЕНКА АЛГОРИТМОВ ПОИСКА
--------------------------------------
##### Крицкий Алексей, группа 9б #####
##### Вариант 6 #####
###### 26.09.2019 ######

______________________________________

* ### Цель работы ###

  Разработка программ, реализующих различные алгоритмы поиска, и оценка их временной и пространственной сложности.

* ### Задания ###

  1. *Знакомство со всеми разделами руководства*

    Со всеми разделами руководства **ознакомился**.

  2. *Получение у преподавателя задания на разработку программы для алгоритмов поиска*

     Задание **получил**: <blockquote>6. Разработать алгоритм и программу **интерполирующего поиска**. В качестве исходных данных использовать массив целых чисел, который формируется с помощью датчика случайных чисел с диапазоном **от 0 до 100**. Аргумент поиска – число.</blockquote>

  3. *Разработка и отладка заданной программы*

    - Словесное описание заданного алгоритма поиска

      0. Входные аргументы:
        - отсорированный по возрастанию массив целых чисел **sortedNumber** (sortedNumber.length - размер массива);
        - целое число **number**;
      1. Инициализация переменных:
        - **leftBoarder** = 0 - левая граница;
        - **rightBoarder** = n-1 - правая граница;

    - Текст программы

      ```java
      int indexOf(final int[] sortedNumbers, int number) {
          int leftBoarder = 0;
          int rightBoarder = sortedNumbers.length - 1;
          int middle;
          while (sortedNumbers[leftBoarder] < number
                  && sortedNumbers[rightBoarder] > number) {
              middle = leftBoarder + (number - leftBoarder) * (rightBoarder - leftBoarder)
                      / (sortedNumbers[rightBoarder] - sortedNumbers[leftBoarder]);
              int middleNumber = sortedNumbers[middle];
              if (middleNumber > number) {
                  leftBoarder = middle + 1;
              } else if (middleNumber < number) {
                  rightBoarder = middle - 1;
              } else {
                  return middle;
              }
          }
          if (sortedNumbers[leftBoarder] == number) {
              return leftBoarder;
          } else if (sortedNumbers[rightBoarder] == number) {
              return rightBoarder;
          } else {
              return -1;
          }
      }
      ```

  4. *Получение верхней и экспериментальной оценки времени выполнения заданного алгоритма и программы*

    + Верхняя оценка времени выполнения

      Пусть n - размер подаваемого массива.

      - Хучший случай

        Это когда, например, значения элементов экспоненциально возрастают. В таком случае линейная интерполяция не даст никакого полезного предсказания, поскольку элемент не предсказанной позиции будет почти всегда меньше искомого, пока размер рассматриваемого диапазона не станет достаточно малым. Т.е. в таком случае может быть выполнено n итераций, и тогда:

        n / 100 - вероятность того, что в массиве есть искомый элемент, тогда

        **Θ{х}(n) =** 2 + f{цикл} + f{условие} = 2 + (3n + nf{тело}) + 3 = 2 + (1 + 3n + n(2 + 2 + 1 + 1 + 1 + 1)) + 3 = 2 + 3n + 8n = **11n + 2**.

      - Лучший случайных

        Это когда

      - Средний случай

        Это когда

      - Итого

        =>

    + Экспериментальная оценка времени выполнения

  5. *Нахождение предельной оценки емкости памяти, необходимой для выполнения разработанной программы*

* ### Вывод ###

  Разработал программу, реализующию один из алгоритмов поиска, а также сделал оценку его временной и пространственной сложности.
